      program matrixinv
c Program to invert tomographic matrix generated by ray*.f
c created by A. Gorbatov
c Last update: 12.11.2001 by Alex
      implicit real*4 (a-h, o-z) 
      character*256 fpar,fvel,fpergl,fperlc,frel,fray,fdel
      character*256 foutl,foutg,frmsout,fcoefh,fcoefv,fvolume
      character*256 cbuffer,flambdacoef
      character*1 cmodel,crmodel,checkmodel
      character*3 yn
      dimension yn(2)
      integer yes,no
      parameter( yes=1,no=2)
      parameter(npcom=440000,nlayer=100,nlayeri=100)
      parameter(numseg=300)
      parameter(maxnumblock=291601)
      parameter(MAXDAT=54000000,MAXROW=2646070)
      dimension numcol(MAXROW)
      dimension delay(MAXROW),b(MAXROW),a(MAXDAT)
      dimension sol(MAXROW),v(MAXROW),w(MAXROW)
      dimension nbl(numseg),rlength(numseg)
      dimension sampling(maxnumblock)
      dimension icol(MAXDAT)
      common /matrix/ a,numcol,icol
*     numseg - number of subsegments of the ray
*     MAXROW - number of rows in the matrix A and B
*     MAXDAT - total number of elements in the matrix A
      dimension icellnum(npcom),pertc(npcom*4)
      dimension xlayer(0:nlayer)
      dimension xlayeri(0:nlayeri)
      dimension coefh(nlayeri),coefv(nlayeri)
      dimension rlambdacoef(nlayer)
      common /param/dx,dy,rmilo,rmalo,rmila,rmala,dxi,dyi,nzi,
     &icellnum,numblock,nxi,nyi,nx,ny,nz
      common /model/ xlayer,xlayeri 
      common /damping/coefh,coefv
      dimension vel1D(npcom),rad1D(npcom)
      common /velmodel/vel1D,rad1D,in1D  
      character*54 head1,head2*154
      character*54 head3,head4*154
      common /head/ head1,head2,head3,head4 
      dimension volumebl(maxnumblock),avelbl(maxnumblock)
      common /volume/ volumebl, avelbl
      integer ifrel,ifray,ifdel,ifrmsout,ifoutl,ifoutg
      common /istream/ ifrel,ifray,ifdel,ifrmsout,ifoutl,ifoutg
     &,ifvolume


* INPUT FILES
* Remember - the list of volumes and average velocities
* should be located below same path as a file of parameterization
* with extension '.volume' of the name of parameterization file
* otherwise the generation of new file is forced automatically
      data fpar
     >/'/home/sudipta/repos/passive-seismic/raytracer/params/param2x2'/
      data fvel
     > /'/home/sudipta/repos/passive-seismic/raytracer/params/ak135.15.SKS'/
      data fpergl
     >/'/home/sudipta/repos/passive-seismic/raytracer/params/perglob2x2.dat'/
      data fperlc
     >/'/home/sudipta/repos/passive-seismic/raytracer/params/perloc2x2.dat'/

      data  frel  /'Preloc.chk.it2'/
      data  fray  /'Praylength.chk.it2'/
      data  fdel  /'Presiduals.chk.it2'/

* OUTPUT FILES ---------------------------------------------------------
      data  frmsout 
     > /'Prmsoutput-joint-asia-restest-chk.it2'/
      data foutl /'Plocsol-asia-rstst.chk.it2'/
      data foutg /'Pglobsol-asia-rstst.chk.it2'/

      data  crmodel /'P'/
*     Maximum RMS for time delay
      data MAXRES /300.0/
*     Damping parameters
c     data rlambda /0.040000000/ good for 3 or 4 iterations
      data rlambda /0.015000000/
*     remember that horizontal cells are 8 when the vertical ones 18
      data dampglobh /1.0/
      data dampglobv /0.5/

*     Number of iterations
      data itmax    /300/
*     Damping for local model- horizontal and vertical
      data   fcoefh 
     &/'0.2 ,0.2 ,0.2 ,0.2 ,0.2 ,.2 ,.2 ,.2 ,.2 ,.2 ,.2 ,
     &.2 ,.2 ,.2 ,.2,.2,.2,.2,.2,.2,.2,.2 '/
      data   fcoefv 
     &/'0.1,0.1,0.1,0.1,0.1,.1 ,.1 ,.1 ,.1 ,.1 ,.1 ,
     &.1 ,.1 ,.1 ,.1 ,.1 ,.1 ,.1 ,.1 ,.1 ,.1 ,.1  '/ 
c     data rmaglambda /0.7/
c     data flambdacoef
c    &/'4.0,4.0,3.0,3.0, 3, 2 , 2 ,1.5,1.5,1.5,1.0,
c        1   2   3   4   5  6   7   8   9   10 11
c    &1.5,1.5,1.5,1.5, 2 ,  2, 2 , 6 , 9 , 9 , 9  '/
c      12  13 14  15  16  17  18  19  20  21  22  

c     data flambdacoef
c    &/' 1,  1,  1,  1,  1, 1 , 1 , 1.0 ,1.0,1.0,1.0,
c        1   2   3   4   5  6   7   8   9   10 11
c    & 1 , 1 , 1 , 1 , 1 , 1 ,1  , 1 , 1 , 1 , 1  '/
c      12  13 14  15  16  17  18  19  20  21  22

c     data rmaglambda /1.0/ is good for global solution when rlambda=0.003
      data rmaglambda /5.0/
      data flambdacoef
     &/'2.0,2.0,2.0,2.0, 2, 2 , 2 ,1.5,1.5,1.5,1.5,
c        1   2   3   4   5  6   7   8   9   10 11
     & 2 , 2 , 2 , 2 , 2 ,  2, 2 , 2 , 2 , 9 , 9  '/
c      12  13 14  15  16  17  18  19  20  21  22


      data relocate     /NO/
      data regionsmooth /YES/
      data globalsmooth /YES/
      data echo         /YES/

*------------ DO NOT CHANGE BELOW !!! --------------------------------

      data ifrel,ifray,ifdel,ifrmsout,ifoutl,ifoutg,ifvolume  
     & /     1,    2,    3,      8,      5,    7,     9    /


*     NOTE: Units 19 and 20 used in the subroutines for scratch


*     scale for relocation to construct matrix (empirical)
      scale=1000.
      yn(yes)='YES'
      yn(no)='NO'
      open(ifdel,file=fdel)
      open(ifrel,file=frel)
      open(ifray,file=fray)
      read(ifdel,'(a1)') cmodel
      print *, 'cmodel: ', cmodel
      if(cmodel.NE.crmodel)then
        write(*,*)
     >'The intended model is ',crmodel,' while loading ',cmodel
       stop
      endif

      call init_vel(fvel,crmodel)

      jj=n_blnk(fpar)
      fvolume = fpar(1:jj) // '.volume' //'_'// cmodel 

      call initvol(fpar)

      if(ifrmsout.NE.6) open(ifrmsout,file=frmsout)
      write(ifrmsout,*)numblock,nx,ny,nz

      read(fcoefh,*,END=999)(coefh(i),i=1,nzi)
      read(fcoefv,*,END=999)(coefv(i),i=1,nzi)
      read(flambdacoef,*,END=999)(rlambdacoef(i),i=1,nz)
      do i=1,nz
        rlambdacoef(i)=rlambdacoef(i)*rmaglambda
      enddo
      goto 9991
999   write(*,*)'Number of damping parameters is
     &less than number of layers in the datalist'
      stop
9991  continue
7777  format(a80)
      
      write(ifrmsout,*)'INPUT FILES:'
      write(ifrmsout,7777)fdel
      write(ifrmsout,7777)frel
      write(ifrmsout,7777)fray
      write(ifrmsout,7777)fvel
      write(ifrmsout,7777)fpar
      write(ifrmsout,7777)fpergl
      write(ifrmsout,7777)fperlc
      write(ifrmsout,*)'OUTPUT FILES:'
      write(ifrmsout,7777)frmsout
      write(ifrmsout,7777)foutl    
      write(ifrmsout,7777)foutg 
      write(ifrmsout,7777)
      write(ifrmsout,*)'INVERSION PARAMETERS'
      write(ifrmsout,*)'Gradient Smoothing'
      if(regionsmooth.EQ.YES)then
         write(ifrmsout,*)'Damping parameters - horizontal:'
         write(ifrmsout,357)(coefh(i),i=1,nzi)
         write(ifrmsout,*)'Damping parameters - vertical: '
         write(ifrmsout,357)(coefv(i),i=1,nzi)
357   format(5f9.5)
      else
         write(ifrmsout,*)'Regional gradient smoothing omitted'
      endif
      if(globalsmooth.EQ.YES)then
      dampglob=dampglobh+dampglobv
      write(ifrmsout,*)'Global damping: ',dampglob
      else
      write(ifrmsout,*)'Global gradient smoothing omitted'
      endif
      write(ifrmsout,*)'Lambda: ',rlambda

      irow=0
      ipin=0
      ndat=0
      maxcl=0
      maxcell=0
      resrms=0.0e10
      ieq = 0

      do i=1,MAXROW
      b(i)=0.0e10
      enddo

      nmax=numblock+nx*ny*nz
      if(nmax.GT.maxnumblock)then
         write(*,*)'Number of cells (nmax) is greater than allowed'
         write(*,*)nmax,' > ',maxnumblock
         stop
      endif
* nmax - maximum number of all  blocks
      do i=1,nmax
        sampling(i)=0.0e10
      enddo

c-------- Volume and average velocity determination for each cell

      nnmax=0
      write(ifrmsout,*)fvolume
      open(ifvolume,file=fvolume,status='OLD',err=17)
      rewind(ifvolume)

      read(ifvolume,*)checkmodel
      if(checkmodel.NE.crmodel)then
      write(*,*)'Velocity and volume file is not ',crmodel
      stop
      endif

      read(ifvolume,*)nnmax

      if(nnmax .NE. nmax)then
      write(ifrmsout,*)'Number of cells in the volume file table'
      write(ifrmsout,*)'does not match the number of cells in the 
     &parameter file.'
      write(ifrmsout,*)nnmax,' and ',  nmax
      write(ifrmsout,*)'Volumes table generation is forced'

      go to 17
      endif

      do i=1,nmax
         read(ifvolume,*)volumebl(i),avelbl(i)
      enddo
      go to 18

17    close(ifvolume) 
      open(ifvolume,file=fvolume)
      write(ifvolume,*)crmodel
      write(ifvolume,*)nmax
      do i=1,nmax
         call cellvol(i,volumebl(i),avelbl(i))
         write(ifvolume,*)volumebl(i),avelbl(i)
      enddo

18    close(ifvolume)
      write(ifrmsout,*)'File of volumes and velocities:'
     &,fvolume

c     call smoothcell(a,numcol,icol,irow,ndat)


c-------------- End volume and velocities initialization
      if(echo.EQ.YES)write(*,*)'Initialization done...'

      rmedval=0.0e10
      irmedval=0


c     goto 4
1     continue

         read(ifdel,*,end=4)resid,iflag
         read(ifrel,120)ncl,rk1,rk2,rk3,rk4
         print *, 'resid, iflag, ncl, rk1, rk2, rk3, rk4'
         print *, resid, iflag, ncl, rk1, rk2, rk3, rk4
120      format(i8,4f8.2)

       ieq=ieq+1
c      write(*,*)ieq

       i=1
2      continue
       read(ifray,*)nbl(i),rlength(i)
       print *, 'nbl'
       print *, nbl
       print *, 'rlength'
       print *, rlength
       if(nbl(i).EQ.0.AND.rlength(i).LT.0.)then
       go to 3
       else
       i=i+1
       go to 2
       endif
3      continue   
       i=i-1


      if(abs(resid).LE.MAXRES)then
       irow=irow+1
       delay(irow)=resid
       b(irow)=resid
       resrms=resrms+resid**2

*       Store number of nonzero elements in each row
     
        
        do j=1,i
         ndat=ndat+1
         icol(ndat)=nbl(j)
         if(maxcell.LT.nbl(j))maxcell=nbl(j)
c        call cellvol(nbl(j),vol,avel)
         a(ndat)=rlength(j)/sqrt(volumebl(nbl(j)))
         sampling(nbl(j))=sampling(nbl(j))+rlength(j)
         if(nbl(j).LE.numblock)then
         rmedval=rmedval+a(ndat)
         irmedval=irmedval+1
         endif
        enddo 
         
      if(relocate.EQ.yes)then
        numcol(irow)=i+4
        n4=nmax+ncl*4
         if(ncl.GT.maxcl)maxcl=ncl
      	ndat=ndat+1
      	icol(ndat)=n4-3
      	a(ndat)=rk1/scale
      	ndat=ndat+1
      	icol(ndat)=n4-2
      	a(ndat)=rk2/scale
      	ndat=ndat+1
      	icol(ndat)=n4-1
      	a(ndat)=rk3/scale
      	ndat=ndat+1
      	icol(ndat)=n4 
      	a(ndat)=rk4/scale
      else
        numcol(irow)=i
      endif
          
      endif 
      goto 1
4     continue

      n4=nmax+maxcl*4

      if(echo.EQ.YES)write(*,*)'Data readed...'
      if(irmedval.LE.0)irmedval=1
      write(ifrmsout,*)
      write(ifrmsout,*)'Relocate? -> ',yn(relocate)
      write(ifrmsout,*)'In the parameter matrix A'
      write(ifrmsout,*)'Average value is ',rmedval/irmedval
      write(ifrmsout,*)'Total columns: ',n4
      write(ifrmsout,*)'Total rows: ', irow
      write(ifrmsout,*)'Nonzero elements: ',ndat
      write(ifrmsout,*)'Maximum cluster (event) number: ',maxcl, 
     &' Maximum block number passed by ray: ',maxcell
      write(ifrmsout,*)
     &'RMS before inversion: ',sqrt(resrms/float(irow-1))
* parameter and Data matrix constructed
* A - parameter matrix
* B - data matrix
* icol - index of nonzero elements in column
* numcol - number of nonzero elements in each row
* irow - number of row in matrix
* ndat - current number of element in matrix A, ndat=numcol*irow
*
*-----------------------------------------------------------------
*  Next is the damping and smoothing matrix

*    Add the Lambda as a global damping for the solution as a lI=b
*    b vector is zero for first iteration in the space of perturbations
*    A is diagonal matrix

      call load_model(b,irow,MAXROW,fperlc,fpergl)

*    Save  perturbations and convert pertturbations of vector b to slownness
*    current volumes and velocities are: volumebl(i),avelbl(i)
      ipert=irow
      do kk=1,nx*ny*nz+numblock
          delay(irow+kk)=b(irow+kk)
          b(irow+kk)=(b(irow+kk)
     &    /(b(irow+kk)*avelbl(kk)+avelbl(kk)*100.))*sqrt(volumebl(kk))
      enddo


      

      do i=1,nmax
         ndat=ndat+1
         irow=irow+1
         if(i.GT.numblock)then
         call rowcol(2,i,nrow,ncol,nlay)
c        a(ndat)=(volumebl(i)/200.)*rlambdacoef(nlay)*rlambda
c    >   rlambda*((volumebl(i)**(1./4.))*(volumebl(i)**(1./5.)) )
c    >   *rlambdacoef(nlay)/6.
         a(ndat)=rlambda*(volumebl(i)**(1./3.))*rlambdacoef(nlay)
         b(irow)=b(irow)*a(ndat)
         else
         a(ndat)=rlambda*(volumebl(i)**(1./3.))
         b(irow)=b(irow)*a(ndat)
         endif
c    >((volumebl(i)**(1./4.))*(volumebl(i)**(1./5.)) )/1000000.)
         icol(ndat)=i
         numcol(irow)=1
      enddo

      write(ifrmsout,*)
      write(ifrmsout,*)'After Lambda inclusion matrix A increased up to'
      write(ifrmsout,*)irow, ' rows'

       if(regionsmooth.EQ.NO)goto 787 
*    Construct smoothing matrix
*    Local

c     irow1=irow
      call smoothcell(a,numcol,icol,irow,ndat)
c     do i=irow1+1,irow
c         numcol(i)=2
c     enddo
      
      if(echo.EQ.YES)write(*,*)'Local damping done...'

      write(ifrmsout,*)
      write(ifrmsout,*)'After local damping kernel inclusion matrix A' 
      write(ifrmsout,*)'increased up to ',irow,' rows 
     &; nonzero elements:',ndat
787   if(globalsmooth.EQ.NO)goto 789
*    Global

      do i=1,nx
       i1=max0(1,i-1)
       i2=min0(nx,i+1)
      do j=1,ny
        j1=max0(1,j-1)
        j2=min0(ny,j+1)
       do k=1,nz
            k1=max0(1,k-1)
            k2=min0(nz,k+1)

           nvol=(i2-i1+1)*(j2-j1+1)*(k2-k1+1)-1 
           nvolh=(i2-i1+1)*(j2-j1+1)-1
           nvolv=(k2-k1)*(i2-i1+1)*(j2-j1+1)
           if((nvolh+nvolv).NE.nvol)write(*,*)'nvol'
           dampglob=dampglobh+dampglobv
            
           do ii=i1,i2
             do jj=j1,j2
               do kk=k1,k2
                if(kk.EQ.k.AND.ii.EQ.i.AND.jj.EQ.j)then
                    ncol=(k-1)*nx*ny+(j-1)*nx+i+numblock
                    ndat=ndat+1
                    a(ndat)=-dampglob
                    icol(ndat)=ncol
c                   write(*,*)ncol,a(ndat)
                else
                    ncol=(kk-1)*nx*ny+(jj-1)*nx+ii+numblock
                    ndat=ndat+1
                    icol(ndat)=ncol
                    if(kk.EQ.k)then
                       a(ndat)=dampglobh/nvolh
c                      write(*,*)ncol,a(ndat)
                    else
                       a(ndat)=dampglobv/nvolv
c                      write(*,*)ncol,a(ndat)
                    endif

                endif
               enddo
             enddo
           enddo

       irow=irow+1
       numcol(irow)=nvol+1 
c      write(*,*)'---',irow,numcol(irow)
       enddo
      enddo
      enddo

      write(ifrmsout,*)
      write(ifrmsout,*)
     &'After global damping kernel inclusion matrix A increased up to'
      write(ifrmsout,*)irow,' rows and  
     &  nonzero elements:',ndat

789   continue
* End of  smoothing
c        write(4,*)irow,ndat
c        write(4,*)(numcol(k),k=1,irow)
c        write(4,100)(icol(k),k=1,ndat)
c100   format(10i8)

c      write(4,200)(a(k),k=1,ndat)
c200   format(10f12.8)

       if(echo.EQ.YES)write(*,*)'Global damping done..'

*  Solve  equation using LSQR

      call pstomo(irow,n4,sol,b,v,w,itmax)

*   Huhhh....
*     
*   Let's see what we have
c   Rescale the values and determine the perturbations
c current volumes and velocities are: volumebl(i),avelbl(i)
       
        do j=1,nmax
*  Rescale....
         rslow=sol(j)/sqrt( volumebl(j))
*  Relative to 3D...
         pert=-rslow*(avelbl(j)*(1.+delay(ipert+j)/100.))*100.
*  Relative to 1D model....
         pertc(j)=pert+delay(ipert+j)+(pert/100.)*delay(ipert+j)
        enddo 

*  Relocation parameters...
c       do j=nmax+1,n4
c         sol(j)=sol(j)/scale
c       enddo
           
*  Output.....

*  Local results

        open(ifoutl,file=foutl)
        write(ifoutl,'(a54)')head1
        write(ifoutl,'(a154)')head2
        write(ifoutl,200)(pertc(icellnum(i)),i=1,nxi*nyi*nzi)
200     format(10f12.5)
        close(ifoutl)

*  Global results

        open(ifoutg,file=foutg)
        write(ifoutg,'(a54)')head3
        write(ifoutg,'(a154)')head4
        write(ifoutg,200)(pertc(i),i=numblock+1,nx*ny*nz+numblock)
        close(ifoutg)
* Some statistic
         pertmax=-1000.
         pertmin=1000.
         pertminav=0.000e10
         pertmaxav=0.000e10
         ipertmaxav=0
         ipertminav=0
       do i=1,nxi*nyi*nzi

         if(sampling(icellnum(i)).GT.0.0)then

         if(pertc(icellnum(i)).GT.pertmax)pertmax=pertc(icellnum(i))
         if(pertc(icellnum(i)).LT.pertmin)pertmin=pertc(icellnum(i))
         if(pertc(icellnum(i)).GT.0.0)then
             pertmaxav=pertmaxav+pertc(icellnum(i))
             ipertmaxav=ipertmaxav+1
         endif
         if(pertc(icellnum(i)).LT.0.0)then
             pertminav=pertminav+pertc(icellnum(i))
             ipertminav=ipertminav+1
         endif

         endif
       enddo

        if(ipertminav.LE.0)ipertminav=1
        if(ipertmaxav.LE.0)ipertmaxav=1
        write(ifrmsout,*)
        write(ifrmsout,*)'Local Max and Min velocity perturbations'
        write(ifrmsout,*)'Min: ',pertmin,'  Max: ',pertmax
        amin=(pertminav/ipertminav)
        amax=(pertmaxav/ipertmaxav)
        write(ifrmsout,*)'Amin: ',amin
        write(ifrmsout,*)'Amax: ',amax

        pertmax=-1000.
        pertmin=1000.
        pertminav=0.000e10
        pertmaxav=0.000e10
        ipertmaxav=0
        ipertminav=0


       do i=numblock+1,nx*ny*nz+numblock
        if(sampling(i).GT.0.0)then

         if(pertc(i).GT.pertmax)pertmax=pertc(i)
         if(pertc(i).LT.pertmin)pertmin=pertc(i)
           if(pertc(i).GT.0.0)then
             pertmaxav=pertmaxav+pertc(i)
             ipertmaxav=ipertmaxav+1
           endif
         if(pertc(i).LT.0.0)then
             pertminav=pertminav+pertc(i)
             ipertminav=ipertminav+1
         endif 
        endif
       enddo

        write(ifrmsout,*)
        write(ifrmsout,*)'Global Max and Min velocity perturbations'
        write(ifrmsout,*)'Min: ',pertmin,'  Max: ',pertmax
        if(ipertminav.LE.0)ipertminav=1
        if(ipertmaxav.LE.0)ipertmaxav=1
        amin=(pertminav/ipertminav)
        amax=(pertmaxav/ipertmaxav)
        write(ifrmsout,*)'Amin: ',amin
        write(ifrmsout,*)'Amax: ',amax



      stop 'No worries, mate...' 
      end
*------------------------------------------ SUBROUTINES

      function n_blnk(cbuffer)
      character*256 cbuffer
      do i=1,256
        if(cbuffer(i:i).EQ.' ')then
          ibl=i
          go to 1
        endif
      enddo
1     n_blnk=ibl-1
      return
      end

      subroutine initvol(name)
*     Load parameterization parameters
      implicit real*4 (a-h, o-z)
      parameter(npcom=440000,nlayer=100,nlayeri=100)
      character*256 name
      dimension icellnum(npcom)
      dimension xlayer(0:nlayer)
      dimension xlayeri(0:nlayeri)
      common /param/dx,dy,rmilo,rmalo,rmila,rmala,dxi,dyi,nzi,
     &icellnum,numblock,nxi,nyi,nx,ny,nz
      common /model/ xlayer,xlayeri
***************************************************
*     READ parameterization
      open(19,file=name)
      read(19,*)nx,ny,nz,dx,dy
c     write(*,*)nx,ny,nz,dx,dy
* Read global layer division data:
      do i=0,nz
      read(19,*)xlayer(i)
      enddo
* Read local layer division data
      read(19,*)rmilo,rmalo,rmila,rmala,nxi,nyi,nzi
      do i=0,nzi
      read(19,*)xlayeri(i)
      enddo


      rmila=90.-rmila
      rmala=90.-rmala
      call minmax(rmila,rmala)
      call minmax(rmilo,rmalo)
      dxi=(rmalo-rmilo)/float(nxi)
      dyi=(rmala-rmila)/float(nyi)
      nmax1=nxi*nyi*nzi
      nmax2=nx*ny*nz+nmax1
      read(19,*)numcel,numblock
      if(numcel.NE.nmax1)then
        write(*,*)'Wrong parameterization!'
        stop
      endif
* Read the target block number:
      read(19,*)(icellnum(i),i=1,nmax1)
      close(19)
c     j=1
c     do i=nmax1+1,nmax2
c       icellnum(i)=numblock+j
c       j=j+1
c     enddo
c     write(*,*)rmilo,rmalo,rmila,rmala,nxi,nyi,nzi
c     write(*,*)numcel,numblock
      return
      end


      subroutine minmax(rmin,rmax)
      implicit real*4 (a-h, o-z)
      if(rmin.LE.rmax)return
      dest=rmin
      rmin=rmax
      rmax=dest
      return
      end



      subroutine cellvol(numcell,vol,avel)
      implicit real*4 (a-h, o-z)
      parameter(npcom=440000,nlayer=100,nlayeri=100)
      dimension icellnum(npcom)
      dimension xlayer(0:nlayer)
      dimension xlayeri(0:nlayeri)
      common /param/dx,dy,rmilo,rmalo,rmila,rmala,dxi,dyi,nzi,
     &icellnum,numblock,nxi,nyi,nx,ny,nz
      common /model/ xlayer,xlayeri
      dimension vel1D(npcom),rad1D(npcom)
      common /velmodel/vel1D,rad1D,in1D  

      vol=0.0e10
      avel=0.0e10
      third=1./3.
      dpi = asin(1.)/ 90.
      nmax1=nxi*nyi*nzi 

               path=0.0e10
               vel=0.0e10

      if(numcell.LE.numblock)then
*                                  Inside of region
         do i=1,nmax1

            if(icellnum(i).EQ.numcell)then
                   call rowcol(1,i,nrow,ncol,nlay)
               
c              if(i.EQ.111)write(*,*)'a ',nrow,ncol,nlay

               rl1=(float(nrow-1)*dyi+rmila)*dpi
               rl2=(float(nrow)*dyi+rmila)*dpi

               f1=(float(ncol-1)*dxi+rmilo)*dpi
               f2=(float(ncol)*dxi+rmilo)*dpi

               r1=(6371.-xlayeri(nlay))
               r2=(6371.-xlayeri(nlay-1))

               do jj=2,in1D

                   if(rad1D(jj).GT.r1.AND.rad1D(jj).LE.r2)then
                        vel=vel+vel1D(jj)*(rad1D(jj-1)-rad1D(jj))
                        path=path+(rad1D(jj-1)-rad1D(jj))
                   endif
               enddo


            

             vol=vol+(((r2+r1)/2.)**2)*sin((rl1+rl2)/2.)
     &              *(rl2-rl1)*(f2-f1)*(r2-r1)



            endif

         enddo



      else
c            write(*,*)'outside' 
                  call rowcol(2,numcell-numblock,nrow,ncol,nlay)

               rl1=float(nrow-1)*dy*dpi
               rl2=float(nrow)*dy*dpi

               f1=float(ncol-1)*dx*dpi
               f2=float(ncol)*dx*dpi

               r1=(6371.-xlayer(nlay))
               r2=(6371.-xlayer(nlay-1))

               do jj=2,in1D

                   if(rad1D(jj).GT.r1.AND.rad1D(jj).LE.r2)then
                        vel=vel+vel1D(jj)*(rad1D(jj-1)-rad1D(jj))
                        path=path+(rad1D(jj-1)-rad1D(jj))
                   endif
               enddo





             vol=vol+(((r2+r1)/2.)**2)*sin((rl1+rl2)/2.)
     &              *(rl2-rl1)*(f2-f1)*(r2-r1)      


      endif

      if(vol.LE.0.)then
c        write(*,*)'vol ',vol
c        write(*,*)((r2+r1)/2.)**2,sin((rl1+rl2)/2.)
c        write(*,*)(rl2-rl1),(f2-f1),(r2-r1)
c     write(*,*)
c    &(((r2+r1)/2.)**2)*sin((rl1+rl2)/2.)*(rl2-rl1)*(f2-f1)*(r2-r1)
         vol=1.
      endif

      if(path.LE.0.)then
c     write(*,*)i,numcell,nrow,ncol,nlay
c     write(*,*)vel,path,vol  
c     write(*,*)r1,r2,rl1,rl2,f1,f2
c     write(*,*)'Check  parameterization'
c     stop
      path=1.
      endif
      if(vel.LE.0.0)vel=5.8

      avel=vel/path

      return
      end


      subroutine rowcol(inout,icell,nrow,ncol,nlay)
      implicit real*4 (a-h, o-z)
      parameter(npcom=440000,nlayer=100,nlayeri=100)
      dimension icellnum(npcom)
      common /param/dx,dy,rmilo,rmalo,rmila,rmala,dxi,dyi,nzi,
     &icellnum,numblock,nxi,nyi,nx,ny,nz

      cell=float(icell)
      if(inout.EQ.1)then
          irow=nyi
          icol=nxi
          ilay=nzi
      else
          irow=ny
          icol=nx
          ilay=nz
      endif

         rlay=float(icell)/float(irow*icol)
         if(float(int(rlay)).LT.rlay)then
                nlay=int(rlay)+1
         else
                nlay=int(rlay)
         endif

              row=float((icell-(nlay-1)*irow*icol))/float(icol) 

               if(float(int(row)).LT.row)then
                  nrow=int(row)+1
               else
                  nrow=int(row)
               endif


         ncol=icell-(nlay-1)*irow*icol-(nrow-1)*icol
c        if(icell.EQ.111)write(*,*)nrow,ncol,nlay
       return
       end
 
      subroutine load_model(b,irow,MAXROW,fperlc,fpergl)
       implicit real*4 (a-h, o-z) 
       dimension b(MAXROW)
       character*256 fperlc,fpergl,fcurrent
       character*54 head1,head2*154 
       character*54 head3,head4*154
       common /head/ head1,head2,head3,head4
      parameter(npcom=440000,nlayer=100,nlayeri=100)
      dimension icellnum(npcom)
      common /param/dx,dy,rmilo,rmalo,rmila,rmala,dxi,dyi,nzi,
     &icellnum,numblock,nxi,nyi,nx,ny,nz

       open(19,file=fperlc)
       fcurrent=fperlc
       rewind(19)
       read(19,'(a54)') head1
       read(19,'(a154)')head2

       if((nx*ny*nz+irow+numblock).GT.MAXROW)then
          write(*,*)'MAXROW should be adjusted up to ',
     &    (nx*ny*nz+irow+numblock)
       endif

       read(19,*,end=22)(b(icellnum(i)+irow),i=1,nxi*nyi*nzi)

       close(19)

       open(20,file=fpergl)
       fcurrent=fpergl
       rewind(20)
       read(20,'(a54)') head3
       read(20,'(a154)')head4

       read(20,*,end=22)(b(j),j=irow+1+numblock,nx*ny*nz+irow+numblock)
       close(20)
       return
22     continue
       write(*,*)'Reading file ',fcurrent
       write(*,*)nx,ny,nz
       write(*,*)'exeed the boundary at ',j,' element'
       write(*,*)'CHECK THE PARAMETERIZATION!!!'
       stop
       return 
       end


      subroutine smoothcell(a,numcol,icol,irow,ndat)
      implicit real*4 (a-h, o-z)
      parameter(npcom=440000,nlayer=100,nlayeri=100)
      parameter(MAXDAT=54000000,MAXROW=2646070)       
      dimension a(MAXDAT) 
      dimension numcol(MAXROW)
      dimension icol(MAXDAT) 
      dimension icellnum(npcom)
      dimension xlayer(0:nlayer)
      dimension xlayeri(0:nlayeri)
      dimension coefh(nlayeri),coefv(nlayeri)
      common /param/dx,dy,rmilo,rmalo,rmila,rmala,dxi,dyi,nzi,
     &icellnum,numblock,nxi,nyi,nx,ny,nz
      common /model/ xlayer,xlayeri
      common /damping/coefh,coefv

C....................................................................   
C                                                                       
C             Construction of the Smoothness Kernel                     
C              in the irregular cell size model                                                                  
C     Output data is one record / one smoothness eq., as                
C         COE   IB1   IB2,                                              
C     which means the eq.                                               
C         COE*M(IB1) - COE*M(IB2) = 0.                                  
c*********************************************************************  
      parameter (d2r=3.1415926535/180.)                                 
      dimension iblock(nyi,nxi,nzi),ri(0:nzi)                               
      dimension ncela(nyi,numblock)
      dimension ncelo(nxi,numblock)
      dimension ncelr(nzi,numblock)
      dimension contcell(numblock*10)
      dimension icontcell(numblock*10,2)
      integer icont
      logical newp                                                      
      write(*,*)'SMOOTHING'
      icont=0
      ma=nyi
      mo=nxi
      mr=nzi
      icount=0
c     call riset(mr,ri)                                                 
      do i=1,nxi
       do j=1,nyi
        do k=1,nzi
        num=(j-1)*nxi+i+(k-1)*nxi*nyi
        iblock(j,i,k)=icellnum(num)
        enddo
       enddo
      enddo
      da=dyi                                                      
      do=dxi                                                        
      dar=da*d2r                                                        
      dor=do*d2r                                                        
      dardor=dar*dor                                                    
       do k=0,nzi
       ri(k)=xlayeri(k)
       enddo
c     ................ Setting NCELL for all blocks                     
c      setting ncell                                       
      do 70 ib=1,numblock                                              
      do 30 ia=1,ma
 30      ncela(ia,ib)=0                                                 
      do 40 io=1,mo   
 40      ncelo(io,ib)=0
      do 50 ir=1,mr   
 50      ncelr(ir,ib)=0
 70   continue
      do 90 ia=1,ma                                                    
         do 90 io=1,mo                                                
            do 90 ir=1,mr                                            
               ib=iblock(ia,io,ir)                                   
               ncela(ia,ib)=ncela(ia,ib)+1                           
               ncelo(io,ib)=ncelo(io,ib)+1
 90            ncelr(ir,ib)=ncelr(ir,ib)+1
c.............................................. df/da ..............    
      write(*,*)'df/da'
      do 190 ia=1,ma-1                                                    
         do 180 io=1,mo
            do 180 ir=1,mr
               ib1=iblock(ia  ,io,ir)                                
               ib2=iblock(ia+1,io,ir)                                
               if(ib1.eq.ib2) go to 180                              
c     .   .   .   .................. determine back scan range          
               ncm=min(ncela(ia,ib1),ncela(ia+1,ib2))                
c               call bascan(ncm,irange)
               irange=ncm
               jrmx=min(ir+irange,mr)                                
               jrmn=max(ir-irange,1)                                 
               jomx=io                                               
               jomn=max(io-irange,1)                                 
c     .   .   .   ............. Back scan to search the same pair       
               newp=.true.                                           
               do 120 jo=jomx,jomn,-1                                
                  do 120 jr=jrmx,jrmn,-1                            
                     if(jo.eq.io.and.jr.ge.ir) goto 120            
                     ib10=iblock(ia,jo,jr)                         
                     ib20=iblock(ia+1,jo,jr)                       
                     if(ib10.eq.ib1.and.ib20.eq.ib2) then          
c     .   .   .   .   .   .   Same pair is found                        
                        newp=.false.                              
                        goto 130                                  
                     end if                                        
 120           continue                                      
 130           continue                                              
c     .   .   .   ............  if IB1-IB2 is a new pair          
               if(newp) then                                         
c     .   .   .   .ppp...........  Serch the same pair
                  coe2=0.
                  jomx=min(io+irange,mo)
                  jomn=io
                  do 170 jo=jomn,jomx
                     do 170 jr=jrmn,jrmx
                        if(jo.eq.io.and.jr.lt.ir) goto  170
                        ib1n=iblock(ia,jo,jr)
                        ib2n=iblock(ia+1,jo,jr)
                        if(ib1n.eq.ib1.and.ib2n.eq.ib2) then
                           dasum=0
c     .   .   .   ............  Summing up lat. block length          
                           do 150 ial=ia,1,-1
                              if (iblock(ial,jo,jr).ne.ib1) goto 155
 150                          dasum=dasum+1
 155                          continue
                           do 160 ial=ia+1,ma,1
                              if (iblock(ial,jo,jr).ne.ib2) goto 165
 160                          dasum=dasum+1
 165                          continue
c     .   .   .   ............  Calculation of COE^2            
                           dr=abs(xlayeri(jr-1)-xlayeri(jr))
                           ala=rmila+ia*da
                           cosa=sin(ala*d2r)
                           avarea=dor*dr*cosa
                           dars=dasum*dar/2
                           coe2=coe2+avarea/dars
                           rhord=coefh(jr)
cc                         write(*,*) dasum
                        end if
 170              continue
c     .   .   .   ............ output
                  coe=sqrt(coe2)*rhord                                     
c                 coe,ib1,ib2                              
c                 ndat=ndat+1
c                 icol(ndat)=ib1
c                 a(ndat)=-coe
c                 ndat=ndat+1
c                 icol(ndat)=ib2
c                 a(ndat)=coe
c                 write(*,*)coe,ib1,ib2
                  icont=icont+1
                  icontcell(icont,1)=ib1
                  icontcell(icont,2)=ib2
                  contcell(icont)=coe
cc                irow=irow+1

               end if                                                
 180     continue                                                  
 190  continue                                                      
c............................................... df/do ...............  
c     write(*,*)'df/do'
      do 290 io=1,mo-1                                                   
c                   | delete -1 and uncomment iop1=mod... for global grid
         iop1=mod(io,mo)+1                                         
         iop1=io+1
         do 280 ia=1,ma                                                
            do 280 ir=1,mr
               ib1=iblock(ia,io  ,ir)                                
               ib2=iblock(ia,iop1,ir)                                
               if(ib1.eq.ib2) go to 280                              
c     .   .   .   .................. determine back scan range          
               ncm=min(ncelo(io,ib1),ncelo(iop1,ib2))                
c               call bascan(ncm,irange)
               irange=ncm
               jrmx=min(ir+irange,mr)                                
               jrmn=max(ir-irange,1)                                 
               jamx=ia                                               
               jamn=max(ia-irange,1)                                 
c     .   .   .   ............. Back scan to search the same pair       
               newp=.true.                                           
2               do 220 ja=jamx,jamn,-1
                  do 220 jr=jrmx,jrmn,-1                            
                     if(ja.eq.ia.and.jr.ge.ir) goto 220            
                     ib10=iblock(ja,io,jr)                         
                     ib20=iblock(ja,iop1,jr)                       
                     if(ib10.eq.ib1.and.ib20.eq.ib2) then          
c     .   .   .   .   .   .   same pair is found                        
                        newp=.false.                              
                        goto 230                                  
                     end if                                        
 220           continue                                      
 230           continue                                              
c     .   .   .   ............ if IB1-IB2 is a new pair          
               if(newp) then                                         
c     .   .   .   ............  Serch the same pair
                  coe2=0.
                  jamx=min(ia+irange,ma)
                  jamn=ia
                  do 270 ja=jamn,jamx
                     do 270 jr=jrmn,jrmx
                        if(ja.eq.ia.and.jr.lt.ir) goto  270
                        ib1n=iblock(ja,io,jr)
                        ib2n=iblock(ja,iop1,jr)
                        if(ib1n.eq.ib1.and.ib2n.eq.ib2) then
c     .   .   .   ............  Summing up long. block length          
                           dosum=0
                           do 250 iol=io,1,-1
                              if (iblock(ja,iol,jr).ne.ib1) goto 255
 250                          dosum=dosum+1
 255                          continue
                           do 260 iol=io+1,mo,1
                              if (iblock(ja,iol,jr).ne.ib2) goto 265
 260                          dosum=dosum+1
 265                          continue
c     .   .   .   ............  Calculation of COE^2            
                           dr=abs(ri(jr-1)-ri(jr))
                           ala=rmila+(ia-.5)*da
                           cosa=sin(ala*d2r)
                           avarea=dar*dr/cosa
                           dors=dosum*dor/2
                           coe2=coe2+avarea/dors
                           rhord=coefh(jr)
cc                         write(*,*) dosum
                        end if
 270              continue
c     .   .   .   ............ Output
                  coe=sqrt(coe2)*rhord
c                 coe,ib1,ib2
c                 ndat=ndat+1
c                 icol(ndat)=ib1
c                 a(ndat)=-coe
c                 ndat=ndat+1
c                 icol(ndat)=ib2
c                 a(ndat)=coe
c                 write(*,*)coe,ib1,ib2
                  icont=icont+1
                  icontcell(icont,1)=ib1
                  icontcell(icont,2)=ib2
                  contcell(icont)=coe

c                 irow=irow+1   
               end if                                                
 280     continue                                                  
 290  continue                                                      
c................................................. df/dr ...........    
      do 490 ir=1,mr-1                                                  
c        write(*,*) ' df/dr   ir=',ir                                  
         do 480 io=1,mo                                                
            do 480 ia=1,ma                                            
               ibu=iblock(ia,io,ir)                                  
               ibd=iblock(ia,io,ir+1)                                
c              write(*,*)'ibu,ibd',ibu,ibd
               if (ibu.eq.ibd) go to 480
c     .   .   .   .................. determine back scan range          
               ncm=min(ncelr(ir,ibu),ncelr(ir+1,ibd))                
c               call bascan(ncm,irange)
               irange=ncm
               jamx=min(ia+irange,ma)                                
               jamn=max(ia-irange,1)                                 
               jomx=io                                               
               jomn=max(io-irange,1)                                 
c     .   .   .   ............. Back scan to search the same pair       
               newp=.true.                                           
               do 420 jo=jomx,jomn,-1                                
                  do 420 ja=jamx,jamn,-1                            
                     if(jo.eq.io.and.ja.ge.ia) goto 420            
                     ibu0=iblock(ja,jo,ir)                         
                     ibd0=iblock(ja,jo,ir+1)                       
                     if(ibu0.eq.ibu.and.ibd0.eq.ibd) then          
c     .   .   .   .   .   .   Same pair is found                        
                        newp=.false.                              
                        goto 430                                  
                  end if                                        
 420           continue                                      
 430           continue                                              
c     .   .   .   ............ if IBU-IBD is a new pair          
               if(newp) then                                         
c              write(*,*)'They are new par'
c     .   .   .   ............  Serch the same pair
                  coe2=0.
                  jomx=min(io+irange,mo)
                  jomn=io
                  do 470 jo=jomn,jomx
                     do 470 ja=jamn,jamx
                        if(jo.eq.io.and.ja.lt.ia) goto  470
                        ibun=iblock(ja,jo,ir)
                        ibdn=iblock(ja,jo,ir+1)
                        if(ibun.eq.ibu.and.ibdn.eq.ibd) then
                           dru=0
                           drd=0
c     .   .   .   ............  Summing up radial block length          
                           do 450 irl=ir,1,-1
                              if (iblock(ja,jo,irl).ne.ibu) goto 455
 450                          dru=dru+1
 455                          continue
                           do 460 irl=ir+1,mr,1
                              if (iblock(ja,jo,irl).ne.ibd) goto 465
 460                          drd=drd+1
 465                          continue
c     .   .   .   ............  Calculation of COE^2            
                           rc2=xlayeri(ir)*xlayeri(ir)
                           ala=rmila+(ja-.5)*da
                           cosa=sin(ala*d2r)
                           avarea=cosa*dardor*rc2
                           dr=abs((ri(ir-dru)-ri(ir+drd))/2.)
                           coe2=coe2+avarea/dr
                           rverd=coefv(ir)
cc                         write(*,*) dru,drd
                        end if
 470              continue
c     .   .   .   ............ Output
                  coe=sqrt(coe2)*rverd
c                 coe,ib1,ib2
c                 ndat=ndat+1
c                 icol(ndat)=ibu
c                 a(ndat)=-coe
c                 ndat=ndat+1
c                 icol(ndat)=ibd
c                 a(ndat)=coe
c                 write(*,*)coe,ibu,ibd
                  icont=icont+1
                  icontcell(icont,1)=ibu
                  icontcell(icont,2)=ibd
                  contcell(icont)=coe
c                 irow=irow+1   
               end if                                                
 480     continue                                              
 490  continue                                                      
c     write(*,*)'-------------------------------------'
      do i=1,numblock
           numjbl=0
           valmax=0.0e10
           do j=1,icont
              if((icontcell(j,1).EQ.i).OR.(icontcell(j,2).EQ.i))then
              valmax=valmax+contcell(j)
              numjbl=numjbl+1
              ndat=ndat+1
              a(ndat)=contcell(j)
c             write(*,*)a(ndat)
              if(icontcell(j,1).EQ.i)then
              icol(ndat)=icontcell(j,2)
              else
              icol(ndat)=icontcell(j,1)
              endif
              endif
           enddo

         if(numjbl.GT.0)then
           ndat=ndat+1
           a(ndat)=-valmax
c          write(*,*)a(ndat)
c          write(*,*)'......................'
           icol(ndat)=i
           irow=irow+1
           numcol(irow)=numjbl+1
         endif

      enddo
c....................................................................   
      end                                                               
c*********************************************************************  
      subroutine bascan(ncm,irange)
c     .   .   .   ............ determine back scan range
      if(ncm.eq.1) then                                     
         irange=0                                          
      else if(ncm.le.4) then                                
         irange=1                                          
      else if(ncm.le.16) then                               
         irange=3                                          
      else if(ncm.le.64) then                               
         irange=7                                          
      else                                                  
         write(*,*) ' ncm is too large ',ncm               
      end if                                                
      return
      end

      subroutine pstomo(m,n,x,u,v,w,itmax)
      implicit real*4 (a-h, o-z) 
*
*   subroutine to solve the linear tomographic problem Ax=u using the
*   lsqr algorithm.
*
c   reference: C.C.Paige and M.A.Saunders, ACM Trans.Math.Softw. 8, 43-71, 1982
c   and ACM Trans.Math.Softw. 8, 195-209, 1982. See also A.v.d.Sluis and H.v.d.
c   Vorst in: G. Nolet (ed.), Seismic Tomography, Reidel, 1987.
c
c   Input: m is the number of data (rows), n the number of unknowns (columns),
c      u contains the data (is overwritten), itmax is the number of iterations.
c   Output: x is the solution; intermediate results are written to a diskfile
c      named <tomo.int> which must not already exist before the call.
c   Scratch: arrays v(n) and w(n)
c   Subroutines: routines avpu and atupv must be supplied by the user.
c      avpu(m,n,u,v) computes u=u+A*v for given input u,v (overwrites u)
c      atupv(m,n,u,v) computes v=v+A(transpose)*u for given u,v (overwrites v)
c
      dimension x(n),u(m),v(n),w(n)
      common /istream/ ifrel,ifray,ifdel,ifrmsout,ifoutl,ifoutg
     &,ifvolume 
      write(ifrmsout,*)'INVERSION'
      write(ifrmsout,'(" iter",6x,"cell 1",9x,"rms",9x,"rel")')

      r=1.0
      do i=1,n 
        x(i)=0 
        v(i)=0 
      enddo

      call normlz(m,u,beta) 
      b1=beta

      call atupv(m,n,u,v) 
      call normlz(n,v,alfa)

      rhobar=alfa 
      phibar=beta
        do i=1,n 
           w(i)=v(i) 
        enddo


       write(ifrmsout,'(i5,3f12.4)') 0,x(1),beta,r

       do iter =1,itmax                         ! repeat for fixed nr of iterations
            a=-alfa 
               do i=1,m 
                u(i)=a*u(i)          ! bidiagonalization
               enddo

          call avpu(m,n,u,v)
          call normlz(m,u,beta)

             b=-beta 
              do i=1,n 
                v(i)=b*v(i) 
              enddo

            call atupv(m,n,u,v)
            call normlz(n,v,alfa)
              rho=sqrt(rhobar*rhobar+beta*beta)    ! modified QR factorization
               c=rhobar/rho 
               s=beta/rho

               teta=s*alfa 
               rhobar=-c*alfa

               phi=c*phibar
               phibar=s*phibar
               t1=phi/rho
               t2=-teta/rho
           do i=1,n                            ! update solution x and storage vector w
             x(i)=t1*w(i)+x(i)
             w(i)=t2*w(i)+v(i)
           enddo 
           r=phibar/b1
      write(ifrmsout,'(i5,3f12.4)') iter,x(1),phibar,r
      enddo 
      return
      end  

      subroutine normlz(n,x,s)
      implicit real*4 (a-h, o-z) 
      dimension x(n)
      s=0.e10
      do i=1,n 
       s=s+x(i)**2
      enddo 
      s=sqrt(s)
      ss=1./s
      do i=1,n 
        x(i)=x(i)*ss 
      enddo
      return 
      end 

      subroutine atupv(m,n,u,v)               
c computes v=v+a(transpose)*u
      implicit real*4 (a-h, o-z) 
      parameter(MAXDAT=54000000,MAXROW=2646070)
      dimension u(m),v(n)
      dimension numcol(MAXROW),a(MAXDAT),icol(MAXDAT) 
      common /matrix/a,numcol,icol
        kount=0
        jj=0
      do i=1,m                               
c work row by row (here too!)
        nc=numcol(i) 
       if (nc.GT.0)then 
        do j=1,nc 
          kount=kount+1
          if(kount.GT.MAXDAT)write(*,*)m,nc,i,j
          jj=icol(kount)
          v(jj)=v(jj)+a(kount)*u(i)          
c add to the right vector element
        enddo
       endif
      enddo
      return
      end 

      subroutine avpu(m,n,u,v)                
*     computes u=u+a*v
      implicit real*4 (a-h, o-z) 
      dimension u(m),v(n)
      parameter(MAXDAT=54000000,MAXROW=2646070)
      dimension numcol(MAXROW),a(MAXDAT),icol(MAXDAT)
      common /matrix/a,numcol,icol
      kount=0
      do i=1,m                              ! work row by row
        nc=numcol(i) 
       if (nc.GT.0) then
         do j=1,nc  
           kount=kount+1
           u(i)=u(i)+a(kount)*v(icol(kount))
         enddo
       endif
      enddo
      return
      end 
      
      subroutine asol(sol,b,m,n)              
*     computes b=a*sol
      implicit real*4 (a-h, o-z) 
      dimension sol(n),b(m)
      parameter(MAXDAT=54000000,MAXROW=2646070)
      dimension numcol(MAXROW),a(MAXDAT),icol(MAXDAT)
      common /matrix/a,numcol,icol
      kount=0
      do i=1,m                               ! work row by row
         b(i)=0.e10
         nc=numcol(i)
          if(nc.GT.0)then                    ! nr of nonzero elements in this row
            do j=1,nc 
              kount=kount+1
              b(i)=b(i)+a(kount)*sol(icol(kount))   ! multiply nonzeroes with vector
            enddo 
          endif
      enddo
      return
      end 
  
      subroutine init_vel(fvel,crmodel)
      implicit real*4 (a-h, o-z)
      character*1 crmodel
      integer imodel
      character*256 fvel
      parameter (npcom=440000)
      dimension vel1D(npcom),rad1D(npcom)
      common /velmodel/vel1D,rad1D,in1D

      if(crmodel.EQ.'P')then
        imodel=1
        write(*,*)'Loading P model...'
      else
        write(*,*)'Loading S model...'
        imodel=2
      endif

      open(19,file=fvel)

      i=0
1     continue
      read(19,*)r,d,vp,vs,rho
      i=i+1
      if(imodel.EQ.1)then
      vel1D(i)=vp         
      else
      vel1D(i)=vs
      endif
      rad1D(i)=float(nint(r))
      if(rad1D(i).LT.100.)goto 2
      goto 1
2     in1D=i
      close(19)
      return
      end
      
